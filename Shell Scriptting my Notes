How to view content of the file
-------------------------------
We can view content of the file by using the following commands:
1. cat
2. tac
3. rev
4. head
5. tail
6. more 
7. less

1. cat
------
cat filename.extension
cat abc.text
cat -n abc.txt [to get the line no.s also]
cat -b abc.txt [to remove blank lines]
cat -nb abc.txt [to remove blank lines and blank spaces]
cat file1 file2 file3 file4 file5 [to view multiple files content simultaneously]
cat -n file1 file2 file3 [get the line no.s of all files]

create a new file with some content
-----------------------------------
cat > filename
---write something on file---
---write something on file---
ctrl+d to save file

to append some extra data to an existing file
---------------------------------------------
cat >> filename
---some more data---
---some more data---

to copy content of one file to another file
-------------------------------------------
cp file1 file2
cat file1 > file2

to append one file content to another file content
--------------------------------------------------
cat file1 >> file2

to copy content of multiple file to a single file
-------------------------------------------------
file1 file2 file3 file4 file5 > total.txt

to append content of multiple file to a single file
-------------------------------------------------
file1 file2 file3 file4 file5 >> total.txt


2. tac[vertical reversal]
-------
It is reverse of cat command means display content in reverse form
here total content will reverse but line not reverse 
cat filename

3. rev[horizontal reversal]
------
rev means reversal
here each line will be reversal 


cat command is best suitable for small files but if large files are there then we should go for head,tail,more,less

4. head
-------
to view specified no of files from top of the file
head -<any number> filename [display only top 5 lines]
head -n -5 filename [it will display all lines from top except last 5 lines]
head -c 100 filename [display first 100 character of the file]


5. tail
-------
to view specified no of files from bottom of the file
tail -<any number> filename [display only top 5 lines]
tail -n -5 filename [it will display last 5 lines]
tail	d -c 100 filename [display first 100 character of the file]



Word Count Command(wc command)
------------------------------
We can count no of words along with that we can count no of lines and no of character present in the given file


wc filename
	no_of_lines , no_of_words , no_of_characters , filename
	
wc a.txt
	6  24 206 a.txt

6 -> no of lines
24 -> no of words
206 -> no of characters

wc -l filename  [get no of lines]
wc -w filename  [get no of words]
wc -c filename  [get no of characters]
wc -wc filename [get no of word and character]
wc -lc filename [get no of line and character]


Redirection
-----------
Redirection is a feature in Linux such that when executing a command, you can change the standard input/output devices. The basic workflow of any Linux command is that it takes an input and give an output.

>>> The standard input (stdin) device is the keyboard.
>>> The standard output (stdout) device is the screen.
With redirection, the above standard input/output can be changed.

Standard Input,Standard Output ,Standard Error are data streams and can flow from one place to another place . We can
can redirect these streams

File				File Descriptor
-------------------------------------------------
Standard Input STDIN	   	       0
Standard Output STDOUT		       1
Standard Error STDERR		       2


1. Redirection Standard Output
------------------------------
>> Standard OP is associated with 1 (0 means standard IP , 1 means standard OP , 2 means standard error)
>> Standard OP connected with terminal
>> By default standard OP connected with terminal but we can redirect this standard OP from terminal to some where else
   based on our req
>> We can perform output redirection by using > and >> symbols


> will perform overwriting of existing data
>> will perform appending to exitsing data

Eg. to redirect standard OP to cat command from terminal to output.txt 


$ cat 1 > output.txt[perform overwriting in file]
$ cat 1 >> output.txt[perform appending of data in file]

	
>> by default > and >> is always meant for ouput redirection only 
>> for using > or >> we don't need to use 1 always it is optional


2. Redirecting standard error
-----------------------------
>> Bydefault standard error device is connected to terminal . Instead of terminal we can redirect error message from 
>> terminal to our required place based on our requirement

cal 1234 

>> We can implement error redirection by using same > and >> symbol
>> Standard error is associated with digit 2

>> $ cal sdsfsdfsfsdfsdf
>> by executing this don't display this error terminal just redirect this error to error.txt
>> in redirection output taking no in command cat 1 > filename [here taking 1 is not compl..]
>> but in redirecting error taking no is compl... cal dfdfdfdf 2>> error.txt

3. Redirection standard input
-----------------------------
>> By default standard ip device is connected with keyboard. but we can redirect from keyboard to somewhere else  
   based on our requirement

>> Standard IP stream associated with 0
>> We can perform input redirection by using < symbol

$ cat 0< a.txt

>> this command is taking input from the a.txt insteam from keyboard[standard input] , it will display OP to standard 
   OP device 
>> here 0 is not compl...

Read IP from a.txt and send that OP to output.txt
-------------------------------------------------
cat 0< a.txt 1> output.txt
cat < a.txt > output.txt

cat < a.txt >> output.txt





Piping Concept
-------------
>> for the command in how many ways we can provide input : cm1 arguement or from standard ip
>> By using piping , multiple commands will work together to fulfill our requirement .
>> We can implement piping concept using | command 

ls -l | wc-l

here standard OP of ls command become standard IP for wc command

ls -l /etc | wc
ls -l /etc | head -10 [getting 10 lines from top]
ls -l /etc | wc | wc -l



Requirement:
------------
the op of LS command should be saved to file output.txt and should be provided to as input to wc command ?

ls -l > output.txt | wc -l
ls -l >> output.txt c -;

In the middle of piping if i use redirection then it breaks pipinf concept



Tee Pipe OR T-Junction
----------------------
In piping if we want to save the OP of one command to afilwaand if we wanr to send one command to a file and if we want
to pass that OP to next command simul.. then we use tee command  		

ls -l | tee output.txt | wc 


Eg. to save output of ls command to a file and display to the terminal simultaenously 

ls -l > output.txt [it will save output of ls to output.txt but won't display it]
ls -l | tee output.txt [get output from ls and save that into output.txt and provide input to next command but next 
                       command is not there so it will display the output to the terminal]


Eg. If i want to save the result of ls -l in output.txt and pass the output to wc command and save that output in     
    wc.txt
    
ls -l | tee output.txt | wc > wc.txt [ls output will save to output.txt and wc output was save to wc.txt]
ls -l | tee output.txt | wc | tee wc.txt [save to the file and display to the terminal also]

NOTE : if we use ls -l | tee output.txt | wc > wc.txt [then it will display the op also	]





Req - 2:
--------
Assumes input.txt contains filenames


input.txt
---------
file1.txt
file2.txt
file3.txt
file4.txt

Read file names from input.txt and remove each file?


cat input.txt ==> Standard Output
rm file1.txt file2.txt file3.txt ==> remove 3 files

remove command always expecting from CMD line args only
but in piping the input is always in stream

cat input.txt | rm
> we have to convert that stream into CMD line args

xargs command:
--------------

cat input.txt | xargs rm

NOTE: in piping next command won't accept stream if it won't accept stram convert it into CMD line args using xargs


>> By using wildcard character we can build regular expression
>> A wildcard character can be used as a substitute for required sequence of characters in regular expression

* --> represent zero or more character i.e any no of characters
? --> represent only one character
[] --> represent range of characters
[abc] --> a or b or c
[!abc] --> except a,b,c
[a-z] --> from small a to small z
[A-Z] --> from capital A to capital Z
[a-zA-Z] --> any upper/lower case character
[0-9] --> any digit from 0 to 9
[a-zA-Z0-9] --> any alpha numeric character
[!a-zA-Z0-9] --> except any alpha numeric character means special characters


[[:lower:]] --> any lower case alphabet symbol
[[:upper:]] --> any upper case alphabet symbol
[[:alpha:]] --> any alphabet symbol
[[:digit:]] --> any digit from 0-9
[[:alnum:]] --> any digit from 0-9
[![:digit:]] --> any character except digit
{} --> list of all files with comma seperator


To list all files
-----------------
1. ls

To list all files with some extension
------------------------------------
ls *.* 

To list all files with .java or .txt extension
---------------------------------------
ls *.java
ls *.txt

To list all files whoose length is 3 
------------------------------------
ls ?? [display all files whoose length is 2]
ls ??? [display all files whoose length is 3]
ls ???? [display all files whoose length is 4]
ls ????? [display all files whoose length is 5]

1. To list all where filename first character is start with a or b or c
----------------------------------------------------------------
ls [abc]*

2. To list all where filename first character is not start with a or b or c
----------------------------------------------------------------
ls [!abc]*


3. To list all files where file name start with lower case alphabet symbol
--------------------------------------------------------------------------
ls [a-z]*
alternative : [[:lower:]]*

4. To list all files where file name start with upper case alphabet symbol
--------------------------------------------------------------------------
ls [A-Z]*
alternative : [[:upper:]]

5. To list all files whose name start with digit
----------------------------------------------
ls [0-9]*
alternative : ls [[:digit:]]

6. To list out all files where first name should be upper case letter and second letter should be a digit and third 
   letter should be a lower case alphabet symbol
---------------------------------------------------------------------------------
ls [A-Z][0-9][a-z]
alternative : ls [[:upper:]][[:digit:]][[:lower:]]

7. To list out all files start with special symbol
---------------------------------------------------
ls [!A-Za-z0-9]
alternative : ls [![:a:]]

8. To copy all files starts with digit to dir1 directory
---------------------------------------------------------
cp [0-9]* dir1

9. To move all files in dir1 which have speicial names
-------------------------------------------------------
mv [[:alpha:]]*.txt dir2

10. Remove all fiels start with a or b or c and ends with e or t
-----------------------------------------------------------------
rx [abc]*[et]

SORT
----
>> sort command sort the file , arranging the records in a particular order
>> by default the sort command sorts file assuming the content are ASCII
>> using option in sort command , it can also be used to sort numerically


1. Sort in alphabetical order
-----------------------------
sort filename.txt

2. Sort on numerical value [option -n]
----------------------------------------
sort filename.txt

3. Sort in reverse order [option -r]
------------------------------------
sort -r filename.txt 

4. Save the sorted results to another file
---------------------------------------
sort -n filename.txt  > filename_sorted.txt

5. Sort Specific Column [option -k]
----------------------------------
sort -t "|" +0 emp1.lst [sort the 0th col of file]
sort -t "|" +1 emp1.lst [sort the 1st col of file]
sort -t "|" +2 emp1.lst [sort the 2nd col of file]
sort -t "|" +5 -n emp1.lst [sort the numeric coloum]

6. reverse the 5th numeric col in file in desc oreder
-------------------------------------------
sort -t "|" -r -n +5 emp1.lst

7. rev the 1st col of file in desc order
----------------------------------------
sort -t "|" -r +1 emp1.lst

8. rev the 2nd col of file in asc order
-----------------------------------------
sort -t "|" +2r emp1.lst

9. start sort from 2nd char of 1st col till goes on 1 col of 4th char
-------------------------------------------------------------------
sort -t "|" +1.2 - 1.4 emp1.lst


CUT COMMAND
-----------
we use cut command to extract data from file
file can be normal or tabular file
suppose if it is normal file


first line
second line
third line


1. cut and display the 3rd col of file
--------------------------------------
cut -d "|" -f3 emp1.lst


FILTERS
---------
1. head
2. tail
3. cut
4. paste
5. sort
6. tr [tr 'a' 'A' < emp.lst] use for replacing
7. tee
8. sed
9. grep
10. fgrep
11. egrep


GREP COMMAND
-------------
grep commands and various options

search single content in file
-----------------------------
grep 'linux' demo.txt [search linux in demo.txt]

search multiple content in the file
-----------------------------------
we have to use -e option which is extended

-e --> to search multiple word in a file
-c --> get the count value of particular word in a file
-i --> to search for both capital and small word

searching particular word
--------------------------
grep -e 'java' -e 'linux' demo.txt [searching for java and linux]

search multiple word in a file
-------------------------------
grep -e 'director' -e 'sales' emp1.lst

get the count value of particular word in a file
-----------------------------------------------
grep -c 'director' emp1.lst

list all files which are having this particular word
----------------------------------------------------
grep -l 'sales' *.lst [list all file which're having sales word]

O/P:
dept.lst
emp1.lst
emp.lst

display file data excluding some word
------------------------------------
grep -v 'sales' emp1.lst


grep wo[od][de]house emp.lst

grep "true*man" emp.lst [print all those names which are having man in word before that anything can be allow]

O/P: trueman
     truman
   
grep wilco[cx*]k*s* emp

NOTE : we use -e option to search multiple word in a file , but we can also use egrep command also which is extended grep 

egrep 'java|linux' demo.txt [search java or linux in demo.txt]

search for woodcock | woodhouse | wodehouse
--------------------------------------------
egrep 'wo(o|d)(d|e)(house|cock)' emp.lst 

search for capital and small both
-----------------------------------
egrep -i 'wo(o|d)(d|e)(house|cock)' emp.lst


grep command always look for the match : "(java|linux)"
grep command can understand patter or not --> yes but not all patterns

grep 'linux' emp.lst [can understand by grep]
grep 'linux|java' emp.lst [can't understand by grep can be understand by egrep]

egrep command can understand all patterns
like : 

>> '^linux' can understand by egrep
>> '(java|linux)' can understand by egrep
 

grep command with -F option:	
-----------------------------
-F means fixed string
if we want to search a group of fixed string then we should have to go for -F option

grep -F "java	
linux 
python " demo.txt

grep -e 'java' -e'python' -e'linux' demo.txt


instead of -F we can use fgrep command


fgrep means ---> fixed string global regular expression print 
fgrep "java
linux
python" demo.txt


fgrep command can understand pattern ?
--------------------------------------
no we've to provide only fixed string .
if we provide like this fgrep "java|python" demo.txt then fgrep didn't understand that java or python is regular 
expression



grep vs egrep vs fgrep
------------------------
1. grep command can understand but not all patterns
   like this grep can undestand this pattern grep ja.. demo.txt [to display all string start with ja]
   but grep can't understand this grep "java|python" demo.txt [to search either java or python string]
   
2. extended grep (egrep) can understand all patterns
3. fixed string grep can't understand any patter , it can accept only fixed string

NOTE:
egrep is not powerfull
fgrep was too good in performance wise
fgrep means fast grep


If we want to search some keyword which was present in file 1 and we want to search all those keyword in file2
---------------------------------------------------------------------------------------------------------------
keyword.txt
----------------
java
python
linux

grep.txt
--------
java
java is good
j2se
j2ee
j2me

linux is created by linus torvalds
python created by guido van rossum
java is created by james gosling
c was created by dennis ritchie
c++ was created by bjarne stroutsrup


fgrep -f file1 file2
fgrep -f keyword.txt grep.txt

O/P: java
     java 
     linux 
     python 
     java 
     
     
egrep ==> grep -e[this is recommended to use]
fgrep ==> grep -F[this is recommended to use]


SED
----
sed '3q' filename [print 3rd col]
sed '3,6p' filename [print from 3 to 6th col]
sed '3,$p' filename 


 |-> Line addressing
 |-> Context addressing
 |-> Text addressing
 |-> Substitution



